{"ast":null,"code":"import io from 'socket.io-client';\nclass SignalingService {\n  constructor() {\n    this.socket = null;\n    this.signalingUrl = process.env.REACT_APP_SIGNALING_URL || 'http://localhost:3001';\n    this.isConnected = false;\n    this.eventListeners = new Map();\n  }\n  connect() {\n    return new Promise((resolve, reject) => {\n      if (this.socket && this.isConnected) {\n        resolve();\n        return;\n      }\n      this.socket = io(this.signalingUrl, {\n        transports: ['websocket', 'polling'],\n        timeout: 10000,\n        reconnection: true,\n        reconnectionAttempts: 5,\n        reconnectionDelay: 1000\n      });\n      this.socket.on('connect', () => {\n        console.log('Connected to signaling server');\n        this.isConnected = true;\n        resolve();\n      });\n      this.socket.on('disconnect', () => {\n        console.log('Disconnected from signaling server');\n        this.isConnected = false;\n      });\n      this.socket.on('connect_error', error => {\n        console.error('Signaling server connection error:', error);\n        reject(error);\n      });\n\n      // Set up event listeners\n      this.setupEventListeners();\n    });\n  }\n  disconnect() {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n      this.isConnected = false;\n    }\n  }\n  setupEventListeners() {\n    // WebRTC session events\n    this.socket.on('session-created', data => {\n      this.emitEvent('session-created', data);\n    });\n    this.socket.on('session-error', data => {\n      this.emitEvent('session-error', data);\n    });\n    this.socket.on('session-closed', data => {\n      this.emitEvent('session-closed', data);\n    });\n\n    // WebRTC signaling events\n    this.socket.on('answer-received', data => {\n      this.emitEvent('answer-received', data);\n    });\n    this.socket.on('ice-candidate-received', data => {\n      this.emitEvent('ice-candidate-received', data);\n    });\n\n    // Point cloud events\n    this.socket.on('pointcloud-data', data => {\n      this.emitEvent('pointcloud-data', data);\n    });\n    this.socket.on('pointcloud-error', data => {\n      this.emitEvent('pointcloud-error', data);\n    });\n    this.socket.on('pointcloud-activated', data => {\n      this.emitEvent('pointcloud-activated', data);\n    });\n\n    // Device stream events\n    this.socket.on('device-stream-started', data => {\n      this.emitEvent('device-stream-started', data);\n    });\n    this.socket.on('device-stream-stopped', data => {\n      this.emitEvent('device-stream-stopped', data);\n    });\n    this.socket.on('device-stream-error', data => {\n      this.emitEvent('device-stream-error', data);\n    });\n  }\n\n  // Event listener management\n  on(event, callback) {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    this.eventListeners.get(event).push(callback);\n  }\n  off(event, callback) {\n    if (this.eventListeners.has(event)) {\n      const listeners = this.eventListeners.get(event);\n      const index = listeners.indexOf(callback);\n      if (index > -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n  emitEvent(event, data) {\n    if (this.eventListeners.has(event)) {\n      this.eventListeners.get(event).forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in event listener for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  // WebRTC session management\n  async createSession(deviceId, streamTypes) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Session creation timeout'));\n      }, 10000);\n      const onSessionCreated = data => {\n        clearTimeout(timeout);\n        this.off('session-created', onSessionCreated);\n        this.off('session-error', onSessionError);\n        resolve(data);\n      };\n      const onSessionError = error => {\n        clearTimeout(timeout);\n        this.off('session-created', onSessionCreated);\n        this.off('session-error', onSessionError);\n        reject(new Error(error.error || 'Failed to create session'));\n      };\n      this.on('session-created', onSessionCreated);\n      this.on('session-error', onSessionError);\n      this.socket.emit('create-session', {\n        deviceId,\n        streamTypes\n      });\n    });\n  }\n  async sendAnswer(sessionId, answer) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Answer processing timeout'));\n      }, 10000);\n      const onAnswerProcessed = () => {\n        clearTimeout(timeout);\n        this.off('answer-received', onAnswerProcessed);\n        this.off('session-error', onSessionError);\n        resolve();\n      };\n      const onSessionError = error => {\n        clearTimeout(timeout);\n        this.off('answer-received', onAnswerProcessed);\n        this.off('session-error', onSessionError);\n        reject(new Error(error.error || 'Failed to process answer'));\n      };\n      this.on('answer-received', onAnswerProcessed);\n      this.on('session-error', onSessionError);\n      this.socket.emit('answer', {\n        sessionId,\n        answer\n      });\n    });\n  }\n  async sendIceCandidate(sessionId, candidate) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('ICE candidate processing timeout'));\n      }, 5000);\n      const onIceProcessed = () => {\n        clearTimeout(timeout);\n        this.off('ice-candidate-received', onIceProcessed);\n        this.off('session-error', onSessionError);\n        resolve();\n      };\n      const onSessionError = error => {\n        clearTimeout(timeout);\n        this.off('ice-candidate-received', onIceProcessed);\n        this.off('session-error', onSessionError);\n        reject(new Error(error.error || 'Failed to process ICE candidate'));\n      };\n      this.on('ice-candidate-received', onIceProcessed);\n      this.on('session-error', onSessionError);\n      this.socket.emit('ice-candidate', {\n        sessionId,\n        candidate\n      });\n    });\n  }\n  async closeSession(sessionId) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Session closure timeout'));\n      }, 5000);\n      const onSessionClosed = data => {\n        clearTimeout(timeout);\n        this.off('session-closed', onSessionClosed);\n        this.off('session-error', onSessionError);\n        resolve(data);\n      };\n      const onSessionError = error => {\n        clearTimeout(timeout);\n        this.off('session-closed', onSessionClosed);\n        this.off('session-error', onSessionError);\n        reject(new Error(error.error || 'Failed to close session'));\n      };\n      this.on('session-closed', onSessionClosed);\n      this.on('session-error', onSessionError);\n      this.socket.emit('close-session', {\n        sessionId\n      });\n    });\n  }\n\n  // Point cloud data\n  async getPointCloudData(deviceId) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Point cloud data request timeout'));\n      }, 10000);\n      const onPointCloudData = data => {\n        clearTimeout(timeout);\n        this.off('pointcloud-data', onPointCloudData);\n        this.off('pointcloud-error', onPointCloudError);\n        resolve(data);\n      };\n      const onPointCloudError = error => {\n        clearTimeout(timeout);\n        this.off('pointcloud-data', onPointCloudData);\n        this.off('pointcloud-error', onPointCloudError);\n        reject(new Error(error.error || 'Failed to fetch point cloud data'));\n      };\n      this.on('pointcloud-data', onPointCloudData);\n      this.on('pointcloud-error', onPointCloudError);\n      this.socket.emit('get-pointcloud-data', {\n        deviceId\n      });\n    });\n  }\n\n  // Device stream control\n  async startDeviceStream(deviceId, configs) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Device stream start timeout'));\n      }, 10000);\n      const onStreamStarted = data => {\n        clearTimeout(timeout);\n        this.off('device-stream-started', onStreamStarted);\n        this.off('device-stream-error', onStreamError);\n        resolve(data);\n      };\n      const onStreamError = error => {\n        clearTimeout(timeout);\n        this.off('device-stream-started', onStreamStarted);\n        this.off('device-stream-error', onStreamError);\n        reject(new Error(error.error || 'Failed to start device stream'));\n      };\n      this.on('device-stream-started', onStreamStarted);\n      this.on('device-stream-error', onStreamError);\n      this.socket.emit('start-device-stream', {\n        deviceId,\n        configs\n      });\n    });\n  }\n  async stopDeviceStream(deviceId) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Device stream stop timeout'));\n      }, 10000);\n      const onStreamStopped = data => {\n        clearTimeout(timeout);\n        this.off('device-stream-stopped', onStreamStopped);\n        this.off('device-stream-error', onStreamError);\n        resolve(data);\n      };\n      const onStreamError = error => {\n        clearTimeout(timeout);\n        this.off('device-stream-stopped', onStreamStopped);\n        this.off('device-stream-error', onStreamError);\n        reject(new Error(error.error || 'Failed to stop device stream'));\n      };\n      this.on('device-stream-stopped', onStreamStopped);\n      this.on('device-stream-error', onStreamError);\n      this.socket.emit('stop-device-stream', {\n        deviceId\n      });\n    });\n  }\n  async activatePointCloud(deviceId, enabled = true) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Point cloud activation timeout'));\n      }, 10000);\n      const onPointCloudActivated = data => {\n        clearTimeout(timeout);\n        this.off('pointcloud-activated', onPointCloudActivated);\n        this.off('pointcloud-error', onPointCloudError);\n        resolve(data);\n      };\n      const onPointCloudError = error => {\n        clearTimeout(timeout);\n        this.off('pointcloud-activated', onPointCloudActivated);\n        this.off('pointcloud-error', onPointCloudError);\n        reject(new Error(error.error || 'Failed to activate point cloud'));\n      };\n      this.on('pointcloud-activated', onPointCloudActivated);\n      this.on('pointcloud-error', onPointCloudError);\n      this.socket.emit('activate-pointcloud', {\n        deviceId,\n        enabled\n      });\n    });\n  }\n\n  // Utility methods\n  getConnectionStatus() {\n    return this.isConnected;\n  }\n  getSocketId() {\n    return this.socket ? this.socket.id : null;\n  }\n}\n\n// Create a singleton instance\nconst signalingService = new SignalingService();\nexport default signalingService;","map":{"version":3,"names":["io","SignalingService","constructor","socket","signalingUrl","process","env","REACT_APP_SIGNALING_URL","isConnected","eventListeners","Map","connect","Promise","resolve","reject","transports","timeout","reconnection","reconnectionAttempts","reconnectionDelay","on","console","log","error","setupEventListeners","disconnect","data","emitEvent","event","callback","has","set","get","push","off","listeners","index","indexOf","splice","forEach","createSession","deviceId","streamTypes","Error","setTimeout","onSessionCreated","clearTimeout","onSessionError","emit","sendAnswer","sessionId","answer","onAnswerProcessed","sendIceCandidate","candidate","onIceProcessed","closeSession","onSessionClosed","getPointCloudData","onPointCloudData","onPointCloudError","startDeviceStream","configs","onStreamStarted","onStreamError","stopDeviceStream","onStreamStopped","activatePointCloud","enabled","onPointCloudActivated","getConnectionStatus","getSocketId","id","signalingService"],"sources":["/home/ubuntu/Projects/realsense-restapi/realsense-react-client/src/services/signalingService.js"],"sourcesContent":["import io from 'socket.io-client';\n\nclass SignalingService {\n  constructor() {\n    this.socket = null;\n    this.signalingUrl = process.env.REACT_APP_SIGNALING_URL || 'http://localhost:3001';\n    this.isConnected = false;\n    this.eventListeners = new Map();\n  }\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      if (this.socket && this.isConnected) {\n        resolve();\n        return;\n      }\n\n      this.socket = io(this.signalingUrl, {\n        transports: ['websocket', 'polling'],\n        timeout: 10000,\n        reconnection: true,\n        reconnectionAttempts: 5,\n        reconnectionDelay: 1000\n      });\n\n      this.socket.on('connect', () => {\n        console.log('Connected to signaling server');\n        this.isConnected = true;\n        resolve();\n      });\n\n      this.socket.on('disconnect', () => {\n        console.log('Disconnected from signaling server');\n        this.isConnected = false;\n      });\n\n      this.socket.on('connect_error', (error) => {\n        console.error('Signaling server connection error:', error);\n        reject(error);\n      });\n\n      // Set up event listeners\n      this.setupEventListeners();\n    });\n  }\n\n  disconnect() {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n      this.isConnected = false;\n    }\n  }\n\n  setupEventListeners() {\n    // WebRTC session events\n    this.socket.on('session-created', (data) => {\n      this.emitEvent('session-created', data);\n    });\n\n    this.socket.on('session-error', (data) => {\n      this.emitEvent('session-error', data);\n    });\n\n    this.socket.on('session-closed', (data) => {\n      this.emitEvent('session-closed', data);\n    });\n\n    // WebRTC signaling events\n    this.socket.on('answer-received', (data) => {\n      this.emitEvent('answer-received', data);\n    });\n\n    this.socket.on('ice-candidate-received', (data) => {\n      this.emitEvent('ice-candidate-received', data);\n    });\n\n    // Point cloud events\n    this.socket.on('pointcloud-data', (data) => {\n      this.emitEvent('pointcloud-data', data);\n    });\n\n    this.socket.on('pointcloud-error', (data) => {\n      this.emitEvent('pointcloud-error', data);\n    });\n\n    this.socket.on('pointcloud-activated', (data) => {\n      this.emitEvent('pointcloud-activated', data);\n    });\n\n    // Device stream events\n    this.socket.on('device-stream-started', (data) => {\n      this.emitEvent('device-stream-started', data);\n    });\n\n    this.socket.on('device-stream-stopped', (data) => {\n      this.emitEvent('device-stream-stopped', data);\n    });\n\n    this.socket.on('device-stream-error', (data) => {\n      this.emitEvent('device-stream-error', data);\n    });\n  }\n\n  // Event listener management\n  on(event, callback) {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    this.eventListeners.get(event).push(callback);\n  }\n\n  off(event, callback) {\n    if (this.eventListeners.has(event)) {\n      const listeners = this.eventListeners.get(event);\n      const index = listeners.indexOf(callback);\n      if (index > -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n\n  emitEvent(event, data) {\n    if (this.eventListeners.has(event)) {\n      this.eventListeners.get(event).forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in event listener for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  // WebRTC session management\n  async createSession(deviceId, streamTypes) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Session creation timeout'));\n      }, 10000);\n\n      const onSessionCreated = (data) => {\n        clearTimeout(timeout);\n        this.off('session-created', onSessionCreated);\n        this.off('session-error', onSessionError);\n        resolve(data);\n      };\n\n      const onSessionError = (error) => {\n        clearTimeout(timeout);\n        this.off('session-created', onSessionCreated);\n        this.off('session-error', onSessionError);\n        reject(new Error(error.error || 'Failed to create session'));\n      };\n\n      this.on('session-created', onSessionCreated);\n      this.on('session-error', onSessionError);\n\n      this.socket.emit('create-session', { deviceId, streamTypes });\n    });\n  }\n\n  async sendAnswer(sessionId, answer) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Answer processing timeout'));\n      }, 10000);\n\n      const onAnswerProcessed = () => {\n        clearTimeout(timeout);\n        this.off('answer-received', onAnswerProcessed);\n        this.off('session-error', onSessionError);\n        resolve();\n      };\n\n      const onSessionError = (error) => {\n        clearTimeout(timeout);\n        this.off('answer-received', onAnswerProcessed);\n        this.off('session-error', onSessionError);\n        reject(new Error(error.error || 'Failed to process answer'));\n      };\n\n      this.on('answer-received', onAnswerProcessed);\n      this.on('session-error', onSessionError);\n\n      this.socket.emit('answer', { sessionId, answer });\n    });\n  }\n\n  async sendIceCandidate(sessionId, candidate) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('ICE candidate processing timeout'));\n      }, 5000);\n\n      const onIceProcessed = () => {\n        clearTimeout(timeout);\n        this.off('ice-candidate-received', onIceProcessed);\n        this.off('session-error', onSessionError);\n        resolve();\n      };\n\n      const onSessionError = (error) => {\n        clearTimeout(timeout);\n        this.off('ice-candidate-received', onIceProcessed);\n        this.off('session-error', onSessionError);\n        reject(new Error(error.error || 'Failed to process ICE candidate'));\n      };\n\n      this.on('ice-candidate-received', onIceProcessed);\n      this.on('session-error', onSessionError);\n\n      this.socket.emit('ice-candidate', { sessionId, candidate });\n    });\n  }\n\n  async closeSession(sessionId) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Session closure timeout'));\n      }, 5000);\n\n      const onSessionClosed = (data) => {\n        clearTimeout(timeout);\n        this.off('session-closed', onSessionClosed);\n        this.off('session-error', onSessionError);\n        resolve(data);\n      };\n\n      const onSessionError = (error) => {\n        clearTimeout(timeout);\n        this.off('session-closed', onSessionClosed);\n        this.off('session-error', onSessionError);\n        reject(new Error(error.error || 'Failed to close session'));\n      };\n\n      this.on('session-closed', onSessionClosed);\n      this.on('session-error', onSessionError);\n\n      this.socket.emit('close-session', { sessionId });\n    });\n  }\n\n  // Point cloud data\n  async getPointCloudData(deviceId) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Point cloud data request timeout'));\n      }, 10000);\n\n      const onPointCloudData = (data) => {\n        clearTimeout(timeout);\n        this.off('pointcloud-data', onPointCloudData);\n        this.off('pointcloud-error', onPointCloudError);\n        resolve(data);\n      };\n\n      const onPointCloudError = (error) => {\n        clearTimeout(timeout);\n        this.off('pointcloud-data', onPointCloudData);\n        this.off('pointcloud-error', onPointCloudError);\n        reject(new Error(error.error || 'Failed to fetch point cloud data'));\n      };\n\n      this.on('pointcloud-data', onPointCloudData);\n      this.on('pointcloud-error', onPointCloudError);\n\n      this.socket.emit('get-pointcloud-data', { deviceId });\n    });\n  }\n\n  // Device stream control\n  async startDeviceStream(deviceId, configs) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Device stream start timeout'));\n      }, 10000);\n\n      const onStreamStarted = (data) => {\n        clearTimeout(timeout);\n        this.off('device-stream-started', onStreamStarted);\n        this.off('device-stream-error', onStreamError);\n        resolve(data);\n      };\n\n      const onStreamError = (error) => {\n        clearTimeout(timeout);\n        this.off('device-stream-started', onStreamStarted);\n        this.off('device-stream-error', onStreamError);\n        reject(new Error(error.error || 'Failed to start device stream'));\n      };\n\n      this.on('device-stream-started', onStreamStarted);\n      this.on('device-stream-error', onStreamError);\n\n      this.socket.emit('start-device-stream', { deviceId, configs });\n    });\n  }\n\n  async stopDeviceStream(deviceId) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Device stream stop timeout'));\n      }, 10000);\n\n      const onStreamStopped = (data) => {\n        clearTimeout(timeout);\n        this.off('device-stream-stopped', onStreamStopped);\n        this.off('device-stream-error', onStreamError);\n        resolve(data);\n      };\n\n      const onStreamError = (error) => {\n        clearTimeout(timeout);\n        this.off('device-stream-stopped', onStreamStopped);\n        this.off('device-stream-error', onStreamError);\n        reject(new Error(error.error || 'Failed to stop device stream'));\n      };\n\n      this.on('device-stream-stopped', onStreamStopped);\n      this.on('device-stream-error', onStreamError);\n\n      this.socket.emit('stop-device-stream', { deviceId });\n    });\n  }\n\n  async activatePointCloud(deviceId, enabled = true) {\n    if (!this.isConnected) {\n      throw new Error('Not connected to signaling server');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Point cloud activation timeout'));\n      }, 10000);\n\n      const onPointCloudActivated = (data) => {\n        clearTimeout(timeout);\n        this.off('pointcloud-activated', onPointCloudActivated);\n        this.off('pointcloud-error', onPointCloudError);\n        resolve(data);\n      };\n\n      const onPointCloudError = (error) => {\n        clearTimeout(timeout);\n        this.off('pointcloud-activated', onPointCloudActivated);\n        this.off('pointcloud-error', onPointCloudError);\n        reject(new Error(error.error || 'Failed to activate point cloud'));\n      };\n\n      this.on('pointcloud-activated', onPointCloudActivated);\n      this.on('pointcloud-error', onPointCloudError);\n\n      this.socket.emit('activate-pointcloud', { deviceId, enabled });\n    });\n  }\n\n  // Utility methods\n  getConnectionStatus() {\n    return this.isConnected;\n  }\n\n  getSocketId() {\n    return this.socket ? this.socket.id : null;\n  }\n}\n\n// Create a singleton instance\nconst signalingService = new SignalingService();\n\nexport default signalingService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}